/* BUSINESS LOGIC TRY
In all of this version we have tried different PRAGMA to enforce proper
vectorization.
The folling PRAGMAs have been tried:
- #pragma ivdep
- #pragma vector aligned
- #pragma simd
- __declspec(align(16, 0))
*/

// original version, the one suggested by Wiki
c[i] = b[i];
for (int j = 0; j < N; j++) {
  if (i != j)
    c[i] = c[i] - A[i][j] * x[j];
}
c[i] = c[i] / A[i][i];

/* USING ser ON mic and XEON
LOOP BEGIN at src/jacobiser.cpp(106,9)
<Predicate Optimized v1>
   remark #25423: Condition at line 107 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents
vectorization
   remark #15346: vector dependence: assumed FLOW dependence between
c.__b_St12_Vector_baseIfSaIfEE._ line 108 and c.__b_St12_Vector_baseIfSaIfEE._
line 108
   remark #15346: vector dependence: assumed ANTI dependence between
c.__b_St12_Vector_baseIfSaIfEE._ line 108 and c.__b_St12_Vector_baseIfSaIfEE._
line 108
   remark #25439: unrolled with remainder by 2
   remark #25018: Total number of lines prefetched=4
   remark #25019: Number of spatial prefetches=2, dist=64
   remark #25021: Number of initial-value prefetches=2
   remark #25035: Number of pointer data prefetches=2, dist=64
   remark #25139: Using second-level distance 8 for prefetching spatial memory
reference   [ src/jacobiser.cpp(108,31) ]
   remark #25141: Using second-level distance 8 for prefetching pointer data
reference   [ src/jacobiser.cpp(108,38) ]
LOOP END
LOOP BEGIN at src/jacobiser.cpp(106,9)
<Predicate Optimized v1>
   remark #25423: Condition at line 107 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents
vectorization
   remark #15346: vector dependence: assumed FLOW dependence between
c.__b_St12_Vector_baseIfSaIfEE._ line 108 and c.__b_St12_Vector_baseIfSaIfEE._
line 108
   remark #15346: vector dependence: assumed ANTI dependence between
c.__b_St12_Vector_baseIfSaIfEE._ line 108 and c.__b_St12_Vector_baseIfSaIfEE._
line 108
   remark #25439: unrolled with remainder by 2
LOOP END
*/

/* USING FASTFLOW ON mic and XEON
LOOP BEGIN at src/jacobiFor.cpp(113,27) inlined into src/jacobiFor.cpp(110,12)
   remark #15523: loop was not vectorized: loop control variable j was found,
but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 8
LOOP END
*/

/* USING THREAD ON mic and XEON respectively
LOOP BEGIN at src/jacobiPar.cpp(98,29)
   remark #15344: loop was not vectorized: vector dependence prevents
vectorization
   remark #15346: vector dependence: assumed FLOW dependence between  line 100
and  line 100
   remark #15346: vector dependence: assumed ANTI dependence between  line 100
and  line 100
   remark #25439: unrolled with remainder by 2
   remark #25018: Total number of lines prefetched=2
   remark #25021: Number of initial-value prefetches=1
   remark #25035: Number of pointer data prefetches=2, dist=64
   remark #25141: Using second-level distance 8 for prefetching pointer data
reference   [ src/jacobiPar.cpp(100,36) ]
LOOP END
LOOP END
LOOP BEGIN at src/jacobiPar.cpp(98,29)
   remark #15344: loop was not vectorized: vector dependence prevents
vectorization
   remark #15346: vector dependence: assumed FLOW dependence between  line 100
and  line 100
   remark #15346: vector dependence: assumed ANTI dependence between  line 100
and  line 100
   remark #25439: unrolled with remainder by 2
LOOP END
*/

/* using a variable sum, to avoid if inside the cycle, we have splitted the for
cycle. We have also used (x1[i] - x2[i]) * (x1[i] - x2[i]) instead of pow in
errorVEC function, beacuse it seams the vectorization acts in different ways*/
sum = b[i];
for (int j = 0; j < i; j++) {
  sum = sum - A[i][j] * x1[j];
}
divisor = A[i][i];
for (int j = i + 1; j < N; j++) {
  sum = sum - A[i][j] * x1[j];
}
x2[i] = sum / divisor;

/* USING ser ON mic and XEON
MIC
remark #15309: vectorization support: normalized vectorization overhead 0.857
remark #15300: LOOP WAS VECTORIZED
remark #15475: --- begin vector loop cost summary ---
remark #15476: scalar loop cost: 14
remark #15477: vector loop cost: 0.430
remark #15478: estimated potential speedup: 20.790
remark #15488: --- end vector loop cost summary ---

errorVEC
remark #15309: vectorization support: normalized vectorization overhead 2.045
remark #15300: LOOP WAS VECTORIZED
remark #15475: --- begin vector loop cost summary ---
remark #15476: scalar loop cost: 18
remark #15477: vector loop cost: 0.680
remark #15478: estimated potential speedup: 18.810
remark #15488: --- end vector loop cost summary ---

XEON
remark #15309: vectorization support: normalized vectorization overhead 3.000
remark #15300: LOOP WAS VECTORIZED
remark #15442: entire loop may be executed in remainder
remark #15448: unmasked aligned unit stride loads: 2
remark #15475: --- begin vector loop cost summary ---
remark #15476: scalar loop cost: 14
remark #15477: vector loop cost: 2.000
remark #15478: estimated potential speedup: 6.030
remark #15488: --- end vector loop cost summary ---

errorVEC
remark #15300: LOOP WAS VECTORIZED
remark #15442: entire loop may be executed in remainder
remark #15448: unmasked aligned unit stride loads: 2
remark #15475: --- begin vector loop cost summary ---
remark #15476: scalar loop cost: 18
remark #15477: vector loop cost: 3.000
remark #15478: estimated potential speedup: 5.370
remark #15488: --- end vector loop cost summary ---
*/

/* USING THREAD ON mic and XEON
MIC
remark #15309: vectorization support: normalized vectorization overhead 0.857
remark #15300: LOOP WAS VECTORIZED
remark #15475: --- begin vector loop cost summary ---
remark #15476: scalar loop cost: 13
remark #15477: vector loop cost: 0.430
remark #15478: estimated potential speedup: 19.300
remark #15488: --- end vector loop cost summary ---

errorVEC
remark #15300: LOOP WAS VECTORIZED
remark #15475: --- begin vector loop cost summary ---
remark #15476: scalar loop cost: 18
remark #15477: vector loop cost: 0.680
remark #15478: estimated potential speedup: 18.810
remark #15488: --- end vector loop cost summary ---


XEON
remark #15300: LOOP WAS VECTORIZED
remark #15442: entire loop may be executed in remainder
remark #15448: unmasked aligned unit stride loads: 2
remark #15475: --- begin vector loop cost summary ---
remark #15476: scalar loop cost: 13
remark #15477: vector loop cost: 2.000
remark #15478: estimated potential speedup: 5.630
remark #15488: --- end vector loop cost summary ---
errroVec
remark #15300: LOOP WAS VECTORIZED
remark #15450: unmasked unaligned unit stride loads: 2
remark #15475: --- begin vector loop cost summary ---
remark #15476: scalar loop cost: 18
remark #15477: vector loop cost: 3.500
remark #15478: estimated potential speedup: 3.090
remark #15488: --- end vector loop cost summary ---
*/

/* USING FASTFLOW ON mic and XEON
MIC
remark #15300: LOOP WAS VECTORIZED
remark #15475: --- begin vector loop cost summary ---
remark #15476: scalar loop cost: 13
remark #15477: vector loop cost: 0.430
remark #15478: estimated potential speedup: 19.300
remark #15488: --- end vector loop cost summary ---

errorVEC
remark #15300: LOOP WAS VECTORIZED
remark #15475: --- begin vector loop cost summary ---
remark #15476: scalar loop cost: 18
remark #15477: vector loop cost: 0.680
remark #15478: estimated potential speedup: 18.810
remark #15488: --- end vector loop cost summary ---

XEON
remark #15300: LOOP WAS VECTORIZED
remark #15442: entire loop may be executed in remainder
remark #15448: unmasked aligned unit stride loads: 2
remark #15475: --- begin vector loop cost summary ---
remark #15476: scalar loop cost: 13
remark #15477: vector loop cost: 2.000
remark #15478: estimated potential speedup: 5.630
remark #15488: --- end vector loop cost summary ---
errorVEC
remark #15300: LOOP WAS VECTORIZED
remark #15442: entire loop may be executed in remainder
remark #15448: unmasked aligned unit stride loads: 2
remark #15475: --- begin vector loop cost summary ---
remark #15476: scalar loop cost: 18
remark #15477: vector loop cost: 3.000
remark #15478: estimated potential speedup: 5.370
*/

/* using A=LDU decomposition, which it calculate directly the \delta_x and
writes it in an array (sum) , two barrier, using the reducer*/
for (size_t i = from; i <= to; i++) {
  d[i] = b[i];
  for (size_t j = 0; j < A.size(); j++) {
    d[i] -= A[i][j] * x[j];
  }
  d[i] /= A[i][i];
  y[i] += d[i];
  sum[thid] += ((d[i] >= 0.0) ? d[i] : -d[i]);
}
bar.await([] { ; });
for (size_t i = from; i <= to; i++) {
  x[i] = y[i];
}
bar.await([worker, &x, &y] {
  startconv = chrono::system_clock::now();
  err = 0;
  for (size_t i = 0; i < worker; i++) {
    err += sum[i];
    sum[i] = 0;
  }
  endconv = chrono::system_clock::now();
});
