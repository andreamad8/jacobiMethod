/* BUSINESS LOGIC TRY
In all of this version we have tried different PRAGMA to enforce proper
vectorization.
The folling PRAGMAs have been tried:
- #pragma ivdep
- #pragma vector aligned
- #pragma simd
- __declspec(align(16, 0))
1. ANTI dependence stands for "READ before WRITE" scenario when considering the
vector version of a loop. In the below, when the compiler auto-vectorizer tries
to vectorize for SSE2 architecture by default, it chooses a vectorlength of 4
(since data type it operates on is int). But when considering a vector operand
instead of scalar operands for this loop, there is an overlap between the input
vector and output vector. The overlap is such those overlapped locations are
read before latest value is written into them.

2. FLOW dependence stands for "WRITE before READ" scenario when considering the
vector version of a loop. In the below, when the compiler auto-vectorizer tries
to vectorize for SSE2 architecture by default, it chooses a vectorlength of 4
(since data type it operates on is int). But when considering a vector operand
instead of scalar operands for this loop, there is an overlap between the input
vector and output vector. The overlap is such those overlapped locations are
written into before their initial value is read for the computation.

*/

// original version, the one suggested by Wiki
c[i] = b[i];
for (int j = 0; j < N; j++) {
  if (i != j)
    c[i] = c[i] - A[i][j] * x[j];
}
c[i] = c[i] / A[i][i];

/* USING ser ON mic and XEON
LOOP BEGIN at src/jacobiser.cpp(106,9)
<Predicate Optimized v1>
   remark #25423: Condition at line 107 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents
vectorization
   remark #15346: vector dependence: assumed FLOW dependence between
c.__b_St12_Vector_baseIfSaIfEE._ line 108 and c.__b_St12_Vector_baseIfSaIfEE._
line 108
   remark #15346: vector dependence: assumed ANTI dependence between
c.__b_St12_Vector_baseIfSaIfEE._ line 108 and c.__b_St12_Vector_baseIfSaIfEE._
line 108
   remark #25439: unrolled with remainder by 2
   remark #25018: Total number of lines prefetched=4
   remark #25019: Number of spatial prefetches=2, dist=64
   remark #25021: Number of initial-value prefetches=2
   remark #25035: Number of pointer data prefetches=2, dist=64
   remark #25139: Using second-level distance 8 for prefetching spatial memory
reference   [ src/jacobiser.cpp(108,31) ]
   remark #25141: Using second-level distance 8 for prefetching pointer data
reference   [ src/jacobiser.cpp(108,38) ]
LOOP END
LOOP BEGIN at src/jacobiser.cpp(106,9)
<Predicate Optimized v1>
   remark #25423: Condition at line 107 hoisted out of this loop
   remark #15344: loop was not vectorized: vector dependence prevents
vectorization
   remark #15346: vector dependence: assumed FLOW dependence between
c.__b_St12_Vector_baseIfSaIfEE._ line 108 and c.__b_St12_Vector_baseIfSaIfEE._
line 108
   remark #15346: vector dependence: assumed ANTI dependence between
c.__b_St12_Vector_baseIfSaIfEE._ line 108 and c.__b_St12_Vector_baseIfSaIfEE._
line 108
   remark #25439: unrolled with remainder by 2
LOOP END
*/

/* USING FASTFLOW ON mic and XEON
LOOP BEGIN at src/jacobiFor.cpp(113,27) inlined into src/jacobiFor.cpp(110,12)
   remark #15523: loop was not vectorized: loop control variable j was found,
but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 8
LOOP END
*/

/* USING THREAD ON mic and XEON respectively
LOOP BEGIN at src/jacobiPar.cpp(98,29)
   remark #15344: loop was not vectorized: vector dependence prevents
vectorization
   remark #15346: vector dependence: assumed FLOW dependence between  line 100
and  line 100
   remark #15346: vector dependence: assumed ANTI dependence between  line 100
and  line 100
   remark #25439: unrolled with remainder by 2
   remark #25018: Total number of lines prefetched=2
   remark #25021: Number of initial-value prefetches=1
   remark #25035: Number of pointer data prefetches=2, dist=64
   remark #25141: Using second-level distance 8 for prefetching pointer data
reference   [ src/jacobiPar.cpp(100,36) ]
LOOP END
LOOP END
LOOP BEGIN at src/jacobiPar.cpp(98,29)
   remark #15344: loop was not vectorized: vector dependence prevents
vectorization
   remark #15346: vector dependence: assumed FLOW dependence between  line 100
and  line 100
   remark #15346: vector dependence: assumed ANTI dependence between  line 100
and  line 100
   remark #25439: unrolled with remainder by 2
LOOP END
*/

// ORIGINAL VERSION WITH #pragma ivdep and #pragma simd
c[i] = b[i];
#pragma ivdep
for (int j = 0; j < N; j++) {
  if (i != j)
    c[i] = c[i] - A[i][j] * x[j];
}
c[i] = c[i] / A[i][i];

/* Using ser

XEON
<Predicate Optimized v1>
remark #25423: Condition at line 109 hoisted out of this loop
remark #15388: vectorization support: reference
A.__b_St12_Vector_baseISt6vectorIfSaIfEESaIS2_EE._M_impl._M_start has aligned
access   [ src/jacobiser.cpp(110,14) ]
remark #15388: vectorization support: reference
x.__b_St12_Vector_baseIfSaIfEE._M_impl._M_start has aligned access   [
src/jacobiser.cpp(110,14) ]
remark #15305: vectorization support: vector length 4
remark #15399: vectorization support: unroll factor set to 2
remark #15309: vectorization support: normalized vectorization overhead 1.375
remark #15301: SIMD LOOP WAS VECTORIZED
remark #15442: entire loop may be executed in remainder
remark #15448: unmasked aligned unit stride loads: 2
remark #15475: --- begin vector loop cost summary ---
remark #15476: scalar loop cost: 18
remark #15477: vector loop cost: 2.000
remark #15478: estimated potential speedup: 7.870
remark #15488: --- end vector loop cost summary ---
LOOP END

*/

/* Using thread


XEON
LOOP BEGIN at src/jacobiPar.cpp(96,5)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either
at Source or due to other Compiler Transformations)
   remark #25451: Advice: Loop Interchange, if possible, might help loopnest.
Suggested Permutation : ( 1 2 ) --> ( 2 1 )
   remark #15344: loop was not vectorized: vector dependence prevents
vectorization
   remark #15346: vector dependence: assumed FLOW dependence between  line 97
and  line 102
   remark #15346: vector dependence: assumed ANTI dependence between  line 102
and  line 97

   LOOP BEGIN at src/jacobiPar.cpp(100,7)
      remark #15336: simd loop was not vectorized: conditional assignment to a
scalar   [ src/jacobiPar.cpp(102,13) ]
      remark #13379: loop was not vectorized with "simd"
      remark #25439: unrolled with remainder by 2
   LOOP END


*/

/* Using FASTFLOW


XEON

LOOP BEGIN at src/jacobiFor.cpp(115,27) inlined into src/jacobiFor.cpp(110,12)
   remark #15389: vectorization support: reference U20a_V has unaligned access
[ src/jacobiFor.cpp(117,32) ]
   remark #15389: vectorization support: reference U20a_V.x has unaligned access
[ src/jacobiFor.cpp(117,32) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 0.218
   remark #15301: SIMD LOOP WAS VECTORIZED
   remark #15475: --- begin vector loop cost summary ---
   remark #15476: scalar loop cost: 23
   remark #15477: vector loop cost: 44.750
   remark #15478: estimated potential speedup: 0.510
   remark #15487: type converts: 1
   remark #15488: --- end vector loop cost summary ---
LOOP END
*/

// ORIGINAL VERSION WITH -02
c[i] = b[i];
for (int j = 0; j < N; j++) {
  if (i != j)
    c[i] = c[i] - A[i][j] * x[j];
}
c[i] = c[i] / A[i][i];

/* Using ser

XEON
<Predicate Optimized v1>
remark #25423: Condition at line 109 hoisted out of this loop
remark #15388: vectorization support: reference
A.__b_St12_Vector_baseISt6vectorIfSaIfEESaIS2_EE._M_impl._M_start has aligned
access   [ src/jacobiser.cpp(110,14) ]
remark #15388: vectorization support: reference
x.__b_St12_Vector_baseIfSaIfEE._M_impl._M_start has aligned access   [
src/jacobiser.cpp(110,14) ]
remark #15305: vectorization support: vector length 4
remark #15399: vectorization support: unroll factor set to 2
remark #15309: vectorization support: normalized vectorization overhead 1.375
remark #15301: SIMD LOOP WAS VECTORIZED
remark #15442: entire loop may be executed in remainder
remark #15448: unmasked aligned unit stride loads: 2
remark #15475: --- begin vector loop cost summary ---
remark #15476: scalar loop cost: 18
remark #15477: vector loop cost: 2.000
remark #15478: estimated potential speedup: 7.870
remark #15488: --- end vector loop cost summary ---
LOOP END

*/

/* Using thread


XEON
LOOP BEGIN at src/jacobiPar.cpp(96,5)
   remark #25096: Loop Interchange not done due to: Imperfect Loop Nest (Either
at Source or due to other Compiler Transformations)
   remark #25451: Advice: Loop Interchange, if possible, might help loopnest.
Suggested Permutation : ( 1 2 ) --> ( 2 1 )
   remark #15344: loop was not vectorized: vector dependence prevents
vectorization
   remark #15346: vector dependence: assumed FLOW dependence between  line 97
and  line 102
   remark #15346: vector dependence: assumed ANTI dependence between  line 102
and  line 97

   LOOP BEGIN at src/jacobiPar.cpp(100,7)
      remark #15336: simd loop was not vectorized: conditional assignment to a
scalar   [ src/jacobiPar.cpp(102,13) ]
      remark #13379: loop was not vectorized with "simd"
      remark #25439: unrolled with remainder by 2
   LOOP END


*/

/* Using FASTFLOW


XEON

LOOP BEGIN at src/jacobiFor.cpp(115,27) inlined into src/jacobiFor.cpp(110,12)
   remark #15389: vectorization support: reference U20a_V has unaligned access
[ src/jacobiFor.cpp(117,32) ]
   remark #15389: vectorization support: reference U20a_V.x has unaligned access
[ src/jacobiFor.cpp(117,32) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 4
   remark #15309: vectorization support: normalized vectorization overhead 0.218
   remark #15301: SIMD LOOP WAS VECTORIZED
   remark #15475: --- begin vector loop cost summary ---
   remark #15476: scalar loop cost: 23
   remark #15477: vector loop cost: 44.750
   remark #15478: estimated potential speedup: 0.510
   remark #15487: type converts: 1
   remark #15488: --- end vector loop cost summary ---
LOOP END
*/

/* using A=LDU decomposition, which it calculate directly the \delta_x and
writes it in an array (sum) , two barrier, using the reducer*/
for (size_t i = from; i <= to; i++) {
  d[i] = b[i];
  for (size_t j = 0; j < A.size(); j++) {
    d[i] -= A[i][j] * x[j];
  }
  d[i] /= A[i][i];
  y[i] += d[i];
  sum[thid] += ((d[i] >= 0.0) ? d[i] : -d[i]);
}
bar.await([] { ; });
for (size_t i = from; i <= to; i++) {
  x[i] = y[i];
}
bar.await([worker, &x, &y] {
  startconv = chrono::system_clock::now();
  err = 0;
  for (size_t i = 0; i < worker; i++) {
    err += sum[i];
    sum[i] = 0;
  }
  endconv = chrono::system_clock::now();
});
