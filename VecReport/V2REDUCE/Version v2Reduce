/* BUSINESS LOGIC TRY
In all of this version we have tried different PRAGMA to enforce proper
vectorization.
The folling PRAGMAs have been tried:
- #pragma ivdep
- #pragma vector aligned
- #pragma simd
- __declspec(align(16, 0))
*/
/// SER
/// PHI
//
// remark #15305: vectorization support: vector length 16
// remark #15399: vectorization support: unroll factor set to 8
// remark #15309: vectorization support: normalized vectorization overhead 0.857
// remark #15300: LOOP WAS VECTORIZED
// remark #15475: --- begin vector loop cost summary ---
// remark #15476: scalar loop cost: 14
// remark #15477: vector loop cost: 0.430
// remark #15478: estimated potential speedup: 20.790
// remark #15488: --- end vector loop cost summary ---

// XEON
// remark #15399: vectorization support: unroll factor set to 2
// remark #15309: vectorization support: normalized vectorization overhead 3.000
// remark #15300: LOOP WAS VECTORIZED
// remark #15442: entire loop may be executed in remainder
// remark #15448: unmasked aligned unit stride loads: 2
// remark #15475: --- begin vector loop cost summary ---
// remark #15476: scalar loop cost: 14
// remark #15477: vector loop cost: 2.000
// remark #15478: estimated potential speedup: 6.030
// remark #15488: --- end vector loop cost summary ---

/// FASTFLOW
ParallelForReduce<float> pf(thread_num, true, true);
err = 1;
startFor = chrono::system_clock::now();
for (size_t k = 0; k <= maxiter and err >= epsilon; k++) {
  pf.parallel_for(0, N, 1, 0,
                  [&](const long i) {
                    float sum;
                    sum = b[i];
                    for (int j = 0; j < i; j++) {
                      sum = sum - A[i][j] * x1[j];
                    }
                    for (int j = i + 1; j < N; j++) {
                      sum = sum - A[i][j] * x1[j];
                    }
                    x2[i] = sum / A[i][i];
                  },
                  thread_num);

  startconv = chrono::system_clock::now();
  swap(x2, x1);
  float sumR = 0.0;
  pf.parallel_reduce(
      sumR, 0.0, 0, N, 1, 0,
      [&](const long i, float &mysum) { mysum += pow(x1[i] - x2[i], 2); },
      [](float &s, const float &e) { s += e; }, thread_num);
  err = sqrt(sumR);
  // err = errorVEC(x2, x1, N);
  endconv = chrono::system_clock::now();
}
endFor = chrono::system_clock::now();

// PHI
// remark #15300: LOOP WAS VECTORIZED
// remark #15475: --- begin vector loop cost summary ---
// remark #15476: scalar loop cost: 13
// remark #15477: vector loop cost: 0.430
// remark #15478: estimated potential speedup: 19.300
// remark #15488: --- end vector loop cost summary ---
// remark #25018: Total number of lines prefetched=32
// remark #25019: Number of spatial prefetches=16, dist=8
// remark #25021: Number of initial-value prefetches=6
// remark #25035: Number of pointer data prefetches=16, dist=8
// LOOP BEGIN at /home/spm1501/public/fastflow/ff/parallel_for.hpp(628,9)
// inlined into src/jacobiFor.cpp(127,12)
// remark #15415: vectorization support: gather was generated for the variable
// U1f9_V:  strided by non-constant value   [ src/jacobiFor.cpp(129,62) ]
// remark #15415: vectorization support: gather was generated for the variable
// U1f9_V:  strided by non-constant value   [ src/jacobiFor.cpp(129,70) ]
// remark #15305: vectorization support: vector length 16
// remark #15309: vectorization support: normalized vectorization overhead 0.458
// remark #15417: vectorization support: number of FP up converts: single
// precision to double precision 1   [
// /opt/mpss/3.5/sysroots/k1om-mpss-linux/usr/include/c++/cmath(384,14) ]
// remark #15417: vectorization support: number of FP up converts: single
// precision to double precision 1   [ src/jacobiFor.cpp(126,20) ]
// remark #15418: vectorization support: number of FP down converts: double
// precision to single precision 1   [ src/jacobiFor.cpp(126,20) ]
// remark #15300: LOOP WAS VECTORIZED
// remark #15460: masked strided loads: 2
// remark #15475: --- begin vector loop cost summary ---
// remark #15476: scalar loop cost: 18
// remark #15477: vector loop cost: 4.500
// remark #15478: estimated potential speedup: 3.660
// remark #15487: type converts: 3
// remark #15488: --- end vector loop cost summary ---
// remark #25018: Total number of lines prefetched=4
// remark #25035: Number of pointer data prefetches=4, dist=8
// remark #25141: Using second-level distance 3 for prefetching pointer data
// reference   [ src/jacobiFor.cpp(129,62) ]
// remark #25141: Using second-level distance 3 for prefetching pointer data
// reference   [ src/jacobiFor.cpp(129,70) ]
// LOOP END

// xeon

// LOOP BEGIN at src/jacobiFor.cpp(114,27) inlined into
// src/jacobiFor.cpp(110,12)
//   remark #15388: vectorization support: reference U217_V has aligned access
//   [ src/jacobiFor.cpp(115,29) ]
//   remark #15388: vectorization support: reference U217_V has aligned access
//   [ src/jacobiFor.cpp(115,29) ]
//   remark #15305: vectorization support: vector length 4
//   remark #15399: vectorization support: unroll factor set to 2
//   remark #15309: vectorization support: normalized vectorization overhead
//   3.000
//   remark #15300: LOOP WAS VECTORIZED
//   remark #15442: entire loop may be executed in remainder
//   remark #15448: unmasked aligned unit stride loads: 2
//   remark #15475: --- begin vector loop cost summary ---
//   remark #15476: scalar loop cost: 13
//   remark #15477: vector loop cost: 2.000
//   remark #15478: estimated potential speedup: 5.630
//   remark #15488: --- end vector loop cost summary ---

// LOOP BEGIN at /home/spm1501/public/fastflow/ff/parallel_for.hpp(628,9)
// inlined into src/jacobiFor.cpp(127,12)
//   remark #15305: vectorization support: vector length 2
//   remark #15399: vectorization support: unroll factor set to 4
//   remark #15309: vectorization support: normalized vectorization overhead
//   0.262
//   remark #15417: vectorization support: number of FP up converts: single
//   precision to double precision 1   [ /usr/include/c++/4.4.7/cmath(390,14) ]
//   remark #15417: vectorization support: number of FP up converts: single
//   precision to double precision 1   [ src/jacobiFor.cpp(126,20) ]
//   remark #15418: vectorization support: number of FP down converts: double
//   precision to single precision 1   [ src/jacobiFor.cpp(126,20) ]
//   remark #15300: LOOP WAS VECTORIZED
//   remark #15460: masked strided loads: 2
//   remark #15475: --- begin vector loop cost summary ---
//   remark #15476: scalar loop cost: 18
//   remark #15477: vector loop cost: 10.000
//   remark #15478: estimated potential speedup: 1.760
//   remark #15487: type converts: 3
//   remark #15488: --- end vector loop cost summary ---

/// THREAD

float sum;
for (size_t k = 0; k <= maxiter and err >= epsilon; k++) {

  for (size_t i = from; i <= to; i++) {
    sum = b[i];
    for (int j = 0; j < i; j++) {
      sum = sum - A[i][j] * x1[j];
    }
    for (int j = i + 1; j < N; j++) {
      sum = sum - A[i][j] * x1[j];
    }
    x2[i] = sum / A[i][i];
  }
  bar.await([&] {});
  startconv = chrono::system_clock::now();
  sum = 0.0;
  for (size_t i = from; i <= to; i++) {
    sum += (x1[i] - x2[i]) * (x1[i] - x2[i]);
  }
  sumR[id] = sum;
  bar.await([&] {
    swap(x2, x1);
    sum = 0;
    for (size_t k = 0; k < thread_num; k++) {
      sum += sumR[k];
    }
    err = sqrt(sum);
    // err = errorVEC(x2, x1, N);
  });

// MIC

// LOOP BEGIN at src/jacobiPar.cpp(100,7)
//    remark #25084: Preprocess Loopnests: Moving Out Store    [
//    src/jacobiPar.cpp(101,9) ]
//    remark #15388: vectorization support: reference (unknown) has aligned
//    access   [ src/jacobiPar.cpp(101,9) ]
//    remark #15388: vectorization support: reference (unknown) has aligned
//    access   [ src/jacobiPar.cpp(101,9) ]
//    remark #15305: vectorization support: vector length 16
//    remark #15399: vectorization support: unroll factor set to 8
//    remark #15309: vectorization support: normalized vectorization overhead
//    0.857
//    remark #15300: LOOP WAS VECTORIZED
//    remark #15475: --- begin vector loop cost summary ---
//    remark #15476: scalar loop cost: 13
//    remark #15477: vector loop cost: 0.430
//    remark #15478: estimated potential speedup: 19.300
//    remark #15488: --- end vector loop cost summary ---
//    remark #25018: Total number of lines prefetched=32
//    remark #25019: Number of spatial prefetches=16, dist=8
//    remark #25021: Number of initial-value prefetches=6
//    remark #25035: Number of pointer data prefetches=16, dist=8

// LOOP BEGIN at src/jacobiPar.cpp(111,5)
// remark #25084: Preprocess Loopnests: Moving Out Store    [
// src/jacobiPar.cpp(112,7) ]
// remark #15388: vectorization support: reference (unknown) has aligned access
// [ src/jacobiPar.cpp(112,7) ]
// remark #15388: vectorization support: reference (unknown) has aligned access
// [ src/jacobiPar.cpp(112,7) ]
// remark #15388: vectorization support: reference (unknown) has aligned access
// [ src/jacobiPar.cpp(112,7) ]
// remark #15388: vectorization support: reference (unknown) has aligned access
// [ src/jacobiPar.cpp(112,7) ]
// remark #15305: vectorization support: vector length 16
// remark #15399: vectorization support: unroll factor set to 2
// remark #15309: vectorization support: normalized vectorization overhead 2.045
// remark #15300: LOOP WAS VECTORIZED
// remark #15475: --- begin vector loop cost summary ---
// remark #15476: scalar loop cost: 16
// remark #15477: vector loop cost: 0.680
// remark #15478: estimated potential speedup: 16.720
// remark #15488: --- end vector loop cost summary ---
// remark #25018: Total number of lines prefetched=8
// remark #25021: Number of initial-value prefetches=6
// remark #25035: Number of pointer data prefetches=8, dist=8

// xeon
// LOOP BEGIN at src/jacobiPar.cpp(100,7)
//  remark #25084: Preprocess Loopnests: Moving Out Store    [
//  src/jacobiPar.cpp(101,9) ]
//  remark #15388: vectorization support: reference (unknown) has aligned access
//  [ src/jacobiPar.cpp(101,9) ]
//  remark #15388: vectorization support: reference (unknown) has aligned access
//  [ src/jacobiPar.cpp(101,9) ]
//  remark #15305: vectorization support: vector length 4
//  remark #15399: vectorization support: unroll factor set to 2
//  remark #15309: vectorization support: normalized vectorization overhead
//  3.000
//  remark #15300: LOOP WAS VECTORIZED
//  remark #15442: entire loop may be executed in remainder
//  remark #15448: unmasked aligned unit stride loads: 2
//  remark #15475: --- begin vector loop cost summary ---
//  remark #15476: scalar loop cost: 13
//  remark #15477: vector loop cost: 2.000
//  remark #15478: estimated potential speedup: 5.630
//  remark #15488: --- end vector loop cost summary ---

// LOOP BEGIN at src/jacobiPar.cpp(111,5)
//    remark #25084: Preprocess Loopnests: Moving Out Store    [
//    src/jacobiPar.cpp(112,7) ]
//    remark #15388: vectorization support: reference (unknown) has aligned
//    access   [ src/jacobiPar.cpp(112,7) ]
//    remark #15388: vectorization support: reference (unknown) has aligned
//    access   [ src/jacobiPar.cpp(112,7) ]
//    remark #15388: vectorization support: reference (unknown) has aligned
//    access   [ src/jacobiPar.cpp(112,7) ]
//    remark #15388: vectorization support: reference (unknown) has aligned
//    access   [ src/jacobiPar.cpp(112,7) ]
//    remark #15305: vectorization support: vector length 4
//    remark #15399: vectorization support: unroll factor set to 2
//    remark #15309: vectorization support: normalized vectorization overhead
//    1.875
//    remark #15300: LOOP WAS VECTORIZED
//    remark #15442: entire loop may be executed in remainder
//    remark #15448: unmasked aligned unit stride loads: 2
//    remark #15475: --- begin vector loop cost summary ---
//    remark #15476: scalar loop cost: 16
//    remark #15477: vector loop cost: 3.000
//    remark #15478: estimated potential speedup: 4.810
//    remark #15488: --- end vector loop cost summary ---
// LOOP END
