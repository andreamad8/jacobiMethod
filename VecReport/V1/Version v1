/* BUSINESS LOGIC TRY
In all of this version we have tried different PRAGMA to enforce proper
vectorization.
The folling PRAGMAs have been tried:
- #pragma ivdep
- #pragma vector aligned
- #pragma simd
- __declspec(align(16, 0))
1. ANTI dependence stands for "READ before WRITE" scenario when considering the
vector version of a loop. In the below, when the compiler auto-vectorizer tries
to vectorize for SSE2 architecture by default, it chooses a vectorlength of 4
(since data type it operates on is int). But when considering a vector operand
instead of scalar operands for this loop, there is an overlap between the input
vector and output vector. The overlap is such those overlapped locations are
read before latest value is written into them.

2. FLOW dependence stands for "WRITE before READ" scenario when considering the
vector version of a loop. In the below, when the compiler auto-vectorizer tries
to vectorize for SSE2 architecture by default, it chooses a vectorlength of 4
(since data type it operates on is int). But when considering a vector operand
instead of scalar operands for this loop, there is an overlap between the input
vector and output vector. The overlap is such those overlapped locations are
written into before their initial value is read for the computation.

*/
/* using a variable sum, to avoid if inside the cycle, we have splitted the for
cycle. We have also used (x1[i] - x2[i]) * (x1[i] - x2[i]) instead of pow in
errorVEC function, beacuse it seams the vectorization acts in different ways*/
sum = b[i];
for (int j = 0; j < i; j++) {
  sum = sum - A[i][j] * x1[j];
}
for (int j = i + 1; j < N; j++) {
  sum = sum - A[i][j] * x1[j];
}
x2[i] = sum / A[i][i];

/* USING ser ON mic and XEON
MIC
remark #15309: vectorization support: normalized vectorization overhead 0.857
remark #15300: LOOP WAS VECTORIZED
remark #15475: --- begin vector loop cost summary ---
remark #15476: scalar loop cost: 14
remark #15477: vector loop cost: 0.430
remark #15478: estimated potential speedup: 20.790
remark #15488: --- end vector loop cost summary ---

errorVEC
remark #15309: vectorization support: normalized vectorization overhead 2.045
remark #15300: LOOP WAS VECTORIZED
remark #15475: --- begin vector loop cost summary ---
remark #15476: scalar loop cost: 18
remark #15477: vector loop cost: 0.680
remark #15478: estimated potential speedup: 18.810
remark #15488: --- end vector loop cost summary ---

XEON
remark #15309: vectorization support: normalized vectorization overhead 3.000
remark #15300: LOOP WAS VECTORIZED
remark #15442: entire loop may be executed in remainder
remark #15448: unmasked aligned unit stride loads: 2
remark #15475: --- begin vector loop cost summary ---
remark #15476: scalar loop cost: 14
remark #15477: vector loop cost: 2.000
remark #15478: estimated potential speedup: 6.030
remark #15488: --- end vector loop cost summary ---

errorVEC
remark #15300: LOOP WAS VECTORIZED
remark #15442: entire loop may be executed in remainder
remark #15448: unmasked aligned unit stride loads: 2
remark #15475: --- begin vector loop cost summary ---
remark #15476: scalar loop cost: 18
remark #15477: vector loop cost: 3.000
remark #15478: estimated potential speedup: 5.370
remark #15488: --- end vector loop cost summary ---
*/

/* USING THREAD ON mic and XEON
MIC
remark #15309: vectorization support: normalized vectorization overhead 0.857
remark #15300: LOOP WAS VECTORIZED
remark #15475: --- begin vector loop cost summary ---
remark #15476: scalar loop cost: 13
remark #15477: vector loop cost: 0.430
remark #15478: estimated potential speedup: 19.300
remark #15488: --- end vector loop cost summary ---

errorVEC
remark #15300: LOOP WAS VECTORIZED
remark #15475: --- begin vector loop cost summary ---
remark #15476: scalar loop cost: 18
remark #15477: vector loop cost: 0.680
remark #15478: estimated potential speedup: 18.810
remark #15488: --- end vector loop cost summary ---


XEON
remark #15300: LOOP WAS VECTORIZED
remark #15442: entire loop may be executed in remainder
remark #15448: unmasked aligned unit stride loads: 2
remark #15475: --- begin vector loop cost summary ---
remark #15476: scalar loop cost: 13
remark #15477: vector loop cost: 2.000
remark #15478: estimated potential speedup: 5.630
remark #15488: --- end vector loop cost summary ---
errroVec
remark #15300: LOOP WAS VECTORIZED
remark #15450: unmasked unaligned unit stride loads: 2
remark #15475: --- begin vector loop cost summary ---
remark #15476: scalar loop cost: 18
remark #15477: vector loop cost: 3.500
remark #15478: estimated potential speedup: 3.090
remark #15488: --- end vector loop cost summary ---
*/

/* USING FASTFLOW ON mic and XEON
MIC
remark #15300: LOOP WAS VECTORIZED
remark #15475: --- begin vector loop cost summary ---
remark #15476: scalar loop cost: 13
remark #15477: vector loop cost: 0.430
remark #15478: estimated potential speedup: 19.300
remark #15488: --- end vector loop cost summary ---

errorVEC
remark #15300: LOOP WAS VECTORIZED
remark #15475: --- begin vector loop cost summary ---
remark #15476: scalar loop cost: 18
remark #15477: vector loop cost: 0.680
remark #15478: estimated potential speedup: 18.810
remark #15488: --- end vector loop cost summary ---

XEON
remark #15300: LOOP WAS VECTORIZED
remark #15442: entire loop may be executed in remainder
remark #15448: unmasked aligned unit stride loads: 2
remark #15475: --- begin vector loop cost summary ---
remark #15476: scalar loop cost: 13
remark #15477: vector loop cost: 2.000
remark #15478: estimated potential speedup: 5.630
remark #15488: --- end vector loop cost summary ---
errorVEC
remark #15300: LOOP WAS VECTORIZED
remark #15442: entire loop may be executed in remainder
remark #15448: unmasked aligned unit stride loads: 2
remark #15475: --- begin vector loop cost summary ---
remark #15476: scalar loop cost: 18
remark #15477: vector loop cost: 3.000
remark #15478: estimated potential speedup: 5.370
*/

/* using A=LDU decomposition, which it calculate directly the \delta_x and
writes it in an array (sum) , two barrier, using the reducer*/
for (size_t i = from; i <= to; i++) {
  d[i] = b[i];
  for (size_t j = 0; j < A.size(); j++) {
    d[i] -= A[i][j] * x[j];
  }
  d[i] /= A[i][i];
  y[i] += d[i];
  sum[thid] += ((d[i] >= 0.0) ? d[i] : -d[i]);
}
bar.await([] { ; });
for (size_t i = from; i <= to; i++) {
  x[i] = y[i];
}
bar.await([worker, &x, &y] {
  startconv = chrono::system_clock::now();
  err = 0;
  for (size_t i = 0; i < worker; i++) {
    err += sum[i];
    sum[i] = 0;
  }
  endconv = chrono::system_clock::now();
});
